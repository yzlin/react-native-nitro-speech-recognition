///
/// Handlers.swift
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

import NitroModules

/**
 * Represents an instance of `Handlers`, backed by a C++ struct.
 */
public typealias Handlers = margelo.nitro.nitrospeechrecognition.Handlers

public extension Handlers {
  private typealias bridge = margelo.nitro.nitrospeechrecognition.bridge.swift

  /**
   * Create a new instance of `Handlers`.
   */
  init(onResult: @escaping (_ result: SpeechRecognitionResultEvent) -> Void, onError: @escaping (_ error: SpeechRecognitionErrorEvent) -> Void, onEvent: @escaping (_ eventType: EventType) -> Void) {
    self.init({ () -> bridge.Func_void_SpeechRecognitionResultEvent in
      let __closureWrapper = Func_void_SpeechRecognitionResultEvent(onResult)
      return bridge.create_Func_void_SpeechRecognitionResultEvent(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_SpeechRecognitionErrorEvent in
      let __closureWrapper = Func_void_SpeechRecognitionErrorEvent(onError)
      return bridge.create_Func_void_SpeechRecognitionErrorEvent(__closureWrapper.toUnsafe())
    }(), { () -> bridge.Func_void_EventType in
      let __closureWrapper = Func_void_EventType(onEvent)
      return bridge.create_Func_void_EventType(__closureWrapper.toUnsafe())
    }())
  }

  var onResult: (_ result: SpeechRecognitionResultEvent) -> Void {
    @inline(__always)
    get {
      return { () -> (SpeechRecognitionResultEvent) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_SpeechRecognitionResultEvent(self.__onResult)
        return { (__result: SpeechRecognitionResultEvent) -> Void in
          __wrappedFunction.call(__result)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onResult = { () -> bridge.Func_void_SpeechRecognitionResultEvent in
        let __closureWrapper = Func_void_SpeechRecognitionResultEvent(newValue)
        return bridge.create_Func_void_SpeechRecognitionResultEvent(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onError: (_ error: SpeechRecognitionErrorEvent) -> Void {
    @inline(__always)
    get {
      return { () -> (SpeechRecognitionErrorEvent) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_SpeechRecognitionErrorEvent(self.__onError)
        return { (__error: SpeechRecognitionErrorEvent) -> Void in
          __wrappedFunction.call(__error)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onError = { () -> bridge.Func_void_SpeechRecognitionErrorEvent in
        let __closureWrapper = Func_void_SpeechRecognitionErrorEvent(newValue)
        return bridge.create_Func_void_SpeechRecognitionErrorEvent(__closureWrapper.toUnsafe())
      }()
    }
  }
  
  var onEvent: (_ eventType: EventType) -> Void {
    @inline(__always)
    get {
      return { () -> (EventType) -> Void in
        let __wrappedFunction = bridge.wrap_Func_void_EventType(self.__onEvent)
        return { (__eventType: EventType) -> Void in
          __wrappedFunction.call(__eventType.rawValue)
        }
      }()
    }
    @inline(__always)
    set {
      self.__onEvent = { () -> bridge.Func_void_EventType in
        let __closureWrapper = Func_void_EventType(newValue)
        return bridge.create_Func_void_EventType(__closureWrapper.toUnsafe())
      }()
    }
  }
}
